from flask import render_template, flash, redirect, url_for, request
from flask_login import login_user, logout_user, current_user, login_required
from werkzeug.urls import url_parse
from flask_server import flask_server, db
from flask_server.forms import LoginForm, RegistrationForm, PostForm, UpdateForm
from flask_server.models import User, Post
from datetime import datetime
from functools import wraps

methods = ["GET", "POST"]


@flask_server.route("/")
@flask_server.route("/index")
@login_required
def index():
    """ The controller to handle incoming GET requests to the root and `/index` URLs of the web server.
    
    1. Uses the [`@login_required decorator`](https://flask-login.readthedocs.io/en/latest/#flask_login.login_required) imported from the [Flask-Login](https://flask-login.readthedocs.io/en/latest/) extension to ensure that the current user is logged-in  before responding with the actual view. 
        a. If the user is not logged in, the [LoginManager.unauthorized()](https://flask-login.readthedocs.io/en/latest/#flask_login.LoginManager.unauthorized) callback is fired, which redirects the user to the `/login` controller.
            - Results from a GET request from an unauthenticated user.
            - This is equivalent to adding to the following to the top of the controller:
                ```
                if not current_user.is_authenticated:
                    return current_app.login_manager.unauthorized()
                ```
        b. If the user is logged in, then the controller retrieves their `user_id` from the current [request context](https://flask.palletsprojects.com/en/1.1.x/reqcontext/). 
            - [`Sessions`](https://flask.palletsprojects.com/en/1.1.x/api/?highlight=session#sessions) makes it possible to persist data between requests (like the `user_id` of the user making requests) ,even though HTTP is a stateless protocol.
            - Results from a GET request from an authenticated user.
        
    2. Fetches the user's posts by querying the SQL database (over HTTP since the it is managed by ClearDB as a SaaS) for all posts associated with their `user_id` (which is the primary key of the Users table).
    
    3. Stores the user's posts as a Python data structure, and makes them available to the `templates/index` view by passing it and the view as parameters to Flask's built-in `render_template()` function.
    
    4. The `templates/index` view uses Jinja2 HTML templating to display:
        - A list of posts created by the logged-in user with links to create/update/delete.
        - Links to view the pitcher dashboard and logout of the app.
    
    Parameters
    ----------
    param1 : string
        The URL being requested by the client.
        
    Returns
    -------
    str
        The index page of the app, as generated by the Jinja2 template.
    """
    posts = current_user.posts
    return render_template("index.html", title="Home", posts=posts)


# GET about view
@flask_server.route("/about")
@login_required
def about():
    return "about this app"


@flask_server.route("/login", methods=methods)
def login():
    """ The controller to handle incoming GET and POST requests to the `/login` URL of the web server.
    
    1. Checks to see if the user is already logged in. If so, returns a response object that redirects the client to the '/index' route.
        - Results from a GET request from an authenticated user.
    
    2. If the user is not already logged in, makes the `LoginForm` (created using Flask-WTF) available to the `templates/login` view by passing it and the view as parameters to Flask's built-in `render_template()` function.
        - Results from a GET request from an unauthenticated user.
    
    3. If data validation occurs (i.e. correct username/pw combo), then the SQL database is queried for the user with the current user's `username`.
        - This operation is safe because the databse enforces unique `usernames`. Also, the `login_user()` method uses the primary key `user_id` to actually log the user in, while this operation simply retrieves the user object.
        - Results from a POST request to this route when the form is sumbitted
    
    4. The response from the database is stored in a Python data structure and the controller makes the user available to the Flask-Login method `login_user()` by passing it as a parameter to that method.
    
    5. The `login_user()` method populates Flask's [request context](https://flask.palletsprojects.com/en/1.1.x/reqcontext/) with the specified user's data (for example, `ctx.user.username` and `ctx.user.user_id`), which can then be accessed by this and other views and controllers.
        - Flask automatically pushes a new request context (`ctx`) to the stack when handling a request. View functions, error handlers, and other functions that run during the request lifecycle will have access to the request proxy, which points to the request object for the current request.
        - Prior to a user logging in, `ctx.user` (an attribute of the context) is an instance of the `AnonymousUserMixin` class.  After a user logs in, `ctx.user` is an instance of the `User` class/SQL database model defined using Flask-SQLAlchemy. 
        - This creates a session, as all subsequent requests will share the same context. Without using sessioins, the user would have to log in each time they wanted to access a protected view instead of just once.
    
    6. The user is redirected to the `index` view after logging in.
    
    Parameters
    ----------
    param1 : string
        The first parameter is the URL being requested by the client.
        
    Returns
    -------
    str
        The login/signup page generated by the Jinja2 template.
    """
    if current_user.is_authenticated:
        return redirect(url_for(url))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.check_password(form.password.data):
            flash("Invalid username or password")
            return redirect(url_for("login"))
        login_user(user, remember=form.remember_me.data)
        next_page = request.args.get("next")
        if not next_page or url_parse(next_page).netloc != "":
            next_page = url_for("index")
        return redirect(next_page)
    return render_template("login.html", title="Sign In", form=form)


@flask_server.route("/logout")
def logout():
    """ The controller to handle incoming GET requests to the `/logout` URL of the web server.
    
    1. Terminates the current user's session and redirects to the `index` route.
    
    Parameters
    ----------
    param1 : string
        The first parameter is the URL being requested by the client.
        
    Returns
    -------
    str
        The lgout page generated by the Jinja2 template.
    """
    logout_user()
    flash("Logged out!")
    return redirect(url_for("index"))


@flask_server.route("/register", methods=methods)
def register():
    """ The controller to handle incoming GET and POST requests to the `/register` URL of the web server.
    
    1. Checks to see if the user is already logged-in and authenticated. If so, returns a response object that redirects the client to the '/index' route.
        - Results from a GET request from an authenticated user.
    
    2. If the user is not already logged-in and authenticated, makes the `RegistrationForm` created using Flask-WTF available to the `templates/register` view by passing the view and the form as parameters to Flask's built-in `render_template()` function.
        - Results from a GET request from an unauthenticated user.
    
    3. If data validation occurs (i.e. username/pw combo is acceptable), then a new row is inserted into the Users table in the SQL database. 
    
    4. The user is redirected to the `login` view. 
    
    Parameters
    ----------
    param1 : string
        The first parameter is the URL being requested by the client.
        
    Returns
    -------
    str
        The register page generated by the Jinja2 template.
    """
    if current_user.is_authenticated:
        return redirect(url_for(url))
    form = RegistrationForm()
    if form.validate_on_submit():
        try:
            user = User(username=form.username.data, email=form.email.data)
            user.set_password(form.password.data)
            db.session.add(user)
            db.session.commit()
            flash("Congratulations, you are now a registered user!")
            return redirect(url_for("login"))
        except:
            flash("Sorry, there was an error registering your account!")
            return redirect(url_for("login"))
    return render_template("register.html", title="Register", form=form)


@flask_server.route("/create", methods=methods)
@login_required
def create_post():
    """ The controller to handle incoming GET and POST requests to the `/create` URL of the web server.
    
    1. Makes the `PostForm` created using Flask-WTF available to the `templates/create` view by passing the view and the form as parameters to Flask's built-in `render_template()` function.
        - Results from a GET request from an authenticated user.
    
    2. If data validation occurs (i.e. post is acceptable), then a new row is inserted into the Posts table in the SQL database. 
    
    3. The user is redirected to the `index` view.
    
    Parameters
    ----------
    param1 : string
        The first parameter is the URL being requested by the client.
        
    Returns
    -------
    str
        The create page generated by the Jinja2 template.
    """
    form = PostForm()
    time = datetime.utcnow()
    if form.validate_on_submit():
        try:
            post = Post(user_id=current_user.id, body=form.body.data)
            db.session.add(post)
            db.session.commit()
            flash("Congratulations, you have successfully created a post!")
            return redirect(url_for("index"))
        except:
            flash("Sorry, there was an error createing your post!")
            return redirect(url_for("index"))
    return render_template("create.html", title="Create Post", form=form)


@flask_server.route("/delete/<int:id>")
@login_required
def delete(id):
    """ The controller to handle incoming GET requests to the `/delete` URL of the web server.
    
    1. Queries the SQL datatbase for the post with the specified `id`. 
    
    2. If the post was created by the logged-in user, then a row is deleted from the Posts table in the SQL database.
        
    4. The user is redirected to the `index` view. 
    
    Parameters
    ----------
    param1 : string
        The first parameter is the URL being requested by the client.
        
    Returns
    -------
    str
        The index page generated by the Jinja2 template.
    """
    post_to_delete = Post.query.get_or_404(id)
    if post_to_delete.user_id is not current_user.id:
        flash("Sorry, you are not authorized to delete that post!")
        return redirect(url_for("index"))
    try:
        db.session.delete(post_to_delete)
        db.session.commit()
        flash("Congratulations, you have successfully deleted a post!")
        return redirect(url_for("index"))
    except:
        flash("Sorry, there was an error deleting your post.")
        return redirect(url_for("index"))


@flask_server.route("/update/<int:id>", methods=methods)
def update(id):
    """ The controller to handle incoming GET and POST requests to the `/update` URL of the web server.
    
    1. Queries the SQL datatbase for the post with the specified `id`. 
    
    2. If the post was created by the logged-in user, then the controller makes the `UpdatePostForm` created using Flask-WTF available to the `templates/update` view by passing the view and the form as parameters to Flask's built-in `render_template()` function.
    
    3. If data validation occurs (i.e. post is acceptable), the row is updated in the Posts table in the SQL database. 
    
    3. The user is redirected to the `index` view.
    
    Parameters
    ----------
    param1 : string
        The first parameter is the URL being requested by the client.
        
    Returns
    -------
    str
        The update page generated by the Jinja2 template.
    """
    post_to_update = Post.query.get_or_404(id)
    if post_to_update.user_id is not current_user.id:
        flash("Sorry, you are not authorized to update that post!")
        return redirect(url_for("index"))
    form = UpdateForm()
    time = datetime.utcnow()
    if form.validate_on_submit():
        try:
            post_to_update.body = form.body.data
            db.session.add(post_to_update)
            db.session.commit()
            flash("Congratulations, you have successfully updated a post!")
            return redirect(url_for("index"))
        except:
            flash("Sorry, there was an error updating your post!")
            return redirect(url_for("index"))
    return render_template(
        "update.html", title="Update Post", form=form, post=post_to_update
    )
